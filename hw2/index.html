<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
				text-align: justify;
				line-height: 1.6;

			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-jaewonheekyung/">cs184.eecs.berkeley.edu/sp25</a>

		<br>
		
		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw2-kmla">cs184.eecs.berkeley.edu/sp25</a>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		<p>
			In this assignment, we work on implementing smooth curve and surfaces. In Section I, we design Bezier Curves and Surfaces. In Section II. we design triangular meshes using half-edge data structure. 
		</p>


		<h2>Section I: Bezier Curves and Surfaces</h2>
		<p>
			<b> Bezier Curves</b><br>
			Bezier curves and surfaces are widely used in computer graphics to represent smooth curves and surfaces. Bezier curves are defined by a set of control points, and the curve itself is a linear combination of these control points. <I>(a.k.a Casteliajau's Algorithm)</I> Bezier curves are defined by a set of control points and  a curve made by Castelijau's algorithm.
		</p>
		<p>
			<b> Castelijau's algorithm </b> <br>
			Castelijau's algorithm is a <I> recursive algorithm </I> to evaluate Bezier curves. It subdivides the control points by inserting a point using linear interpolation between two control points. This process is recursively repeated until we reach a single point. The final point we reached is the point on the Bezier curve.

			Given n control points \( p_1, \dots, p_n \), we use linear interpolation using lerp function, defined <br>
			<p>
				\( p_i' = \text{lerp}(p_i, p_{i+1}, t) = (1 - t) p_i + t p_{i+1} \)
			</p>
			Each call to this function will return the next set of control points \( p_1', \dots, p_{n-1}' \). We repeat this process until we reach a single point.
		</p>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		<p>
			<b> Implementation to evaluate Bezier Curves </b> <br> 
			As explained as the Castelijau's algorithm, we implemented function <code>std::vector<Vector2D> BezierCurve::evaluateStep</code> <br>
			Here, we define function <code> lerp() </code> that calculates the linear interpolation between two points.
			Function <code> EvaluateStep() </code> gets all the control points as an input and returns the next set of control points. We recursively call this fuction until we reach a single point on the Bezier curve.
		</p>
		<p>
			<b> Example of Bezier Curve </b> <br>
			Below, we have created an example of 6 control points. Each image shows the next step of Castelijau's algorithm. The final image shows the Bezier curve we created. We also added an example of changing the t parameter.

		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="./image/Bezier_1.png" width="400px"/>
				  <figcaption>Step 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="./image/Bezier_2.png" width="400px"/>
				  <figcaption>Step 2</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="./image/Bezier_3.png" width="400px"/>
				  <figcaption>Step 3</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="./image/Bezier_4.png" width="400px"/>
				  <figcaption>Step 4</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="./image/Bezier_5.png" width="400px"/>
				  <figcaption>Step 5</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="./image/Bezier_6.png" width="400px"/>
				  <figcaption>Step 6 (with the curve)</figcaption>
				</td>
			  </tr>
			  
			  <tr>
				<td style="text-align: center;">
				  <img src="./image/Bezier_t.png" width="400px"/>
				  <figcaption>t and control points changed </figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		<p>
			<b> Bezier Surfaces </b> <br> 
			Bezier surface is defined in two parameters <b>u</b> and <b> v</b>. The control points are an array of nxn matrix. <br>
		</p>

		<p>
			<b> Implementation to evaluate Bezier Surfaces </b> <br> 
			With the similar logic with the Bezier curves, we implemented function <code>std::vector<Vector3D> BezierPatch::evaluateSte</code>. 
			<code>The function std::vector<Vector3D> BezierPatch::evaluateStep</code> first evaluates a Bézier curve for each row of control points. Then, another Bézier curve is evaluated on the resulting intermediate points at parameter v, producing a single final point on the Bézier surface.
			Using function <code> Vector3D BezierPatch::evaluate1D </code>, we fully evaluate de Casteljau's algorithm for a vector of points at scalar parameter t. 
			Also using function <code> Vector3D BezierPatch::evaluate</code>, we evaluate the Bezier surface at a given (u, v) parameter.
		</p>

		<p>
			<b> Example of Bezier surfaces </b> <br>
			To check the implementation, we created a Bezier surface on the screen, drawing a teapot.
		</p>

		<p>
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
				<td style="text-align: center;">
				  <img src="./image/teapot_1.png" width="400px"/>
				  <figcaption>teapot_1</figcaption>
				</td>
					<td style="text-align: center;">
					<img src="./image/teapot_2.png" width="400px"/>
					<figcaption>teapot_2</figcaption>
			</tr>
			</table>
		</p>
		

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>
		<h3>Part 3: Area-weighted vertex normals</h3>
		<p>
			TODOOO
		</p>

		<h3>Part 4: Edge flip</h3>
		To modify a mesh, there are several methods, and one of them is <b>flipping</b> the edge. The important part is that we have to maintain the structure of the Half-edge structure consistent, ensuring every pointer is assigne correctly. <br>
		We first start with two triangles (a, b, c) and (c, b, d). After flipping, the two triangles are removed and are replaced with two triangles (a, b, d) and (a, d, c).<br> <br>
		<b> Diagram of the Half-edge triangle data structure</b> <br> 
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
					<img src="./image/edgesplit_1.jpg" width="400px"/>
					<figcaption>Teapot before Edge flip</figcaption>
				  </td>
				<td style="text-align: center;">
				  <img src="./image/edge_flip_a.jpg" width="400px"/>
				  <figcaption>Teapot Edge flip</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<br>
		<br>
		<b>Example of Edge flip on teapot surface </b> <br> <br>
		
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
					<img src="./image/Teapot_split_b.png" width="400px"/>
					<figcaption>Teapot before Edge flip</figcaption>
				  </td>
				<td style="text-align: center;">
				  <img src="./image/teapot_edge_flip.png" width="400px"/>
				  <figcaption>Teapot Edge flip</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 5: Edge split</h3>
		<p>
			Like Edge flip, Edge split is a way to modify the mesh. We first start with two triangles (a, b, c) and (c, b, d). After spliting, the two triangles are removed and are replaced with four triangles (a, b, e), (b, c, e), (c, d, e), (d, a, e).

			Here is the diagram we designed to properly assign the new vertices, edges and half edges. <br> <br>
			<b> Diagram of the Half-edge triangle data structure</b> <br>
		</p>
		<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
			  <td style="text-align: center;">
				<img src="./image/edgesplit_1.jpg" width="400px"/>
				<figcaption>Before Edge split</figcaption>
			  </td>
			  <td style="text-align: center;">
				<img src="./image/edgesplit_2.jpg" width="400px"/>
				<figcaption>After Edge split</figcaption>
			  </td>
			</tr>
		  </table>
		<p>
			Here, edge split is more complicated than edge flip because we have to assign new vertices and edges. We have to make sure that the half-edge structure is consistent.At first it was confusing but after drawing the right diagram and printing the positions of the vertices, we could assign all the pointers properly.

			Especially, it was though to ensure that every half-edge and edge, face, vertices were assigned properly. We used the function `check_for()` to debug everything is good.
	
			Here are the images of the mesh of a teapot before and after edge split. We split three triangles. <br>
		</p>

		<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
			  <td style="text-align: center;">
				<img src="./image/Teapot_split_b.png" width="300px"/>
				<figcaption>Teapot before Edge split</figcaption>
			  </td>
			  <td style="text-align: center;">
				<img src="./image/Teapot_split_a.png" width="300px"/>
				<figcaption>Teapot after Edge split</figcaption>
			  </td>
			  <td style="text-align: center;">
				<img src="./image/teapot_flip_and_split.png" width="300px"/>
				<figcaption>Teapot after Edge split</figcaption>
			  </td>
			</tr>
		</table>

		
		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		</div>
	</body>
</html>