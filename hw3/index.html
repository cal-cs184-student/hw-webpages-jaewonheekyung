<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 3 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		
		<figure>
			<img src="cornell.png" alt="Cornell Boxes with Bunnies" style="width:70%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Part 1: Ray Generation and Scene Intersection</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="cornell.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="cornell.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="cornell.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="cornell.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Part 2: Bounding Volume Hierarchy</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Part 3: Direct Illumination</h2>
		<p>
			In Part 3, we begin simulating realistic light transport in the scene by modifying the 
			<code>est_radiance_global_illumination</code> function in <code>pathtracer.cpp</code>, which initially returns a debug color based on surface normals. 
			The Bidirectional Scattering Distribution Function (BSDF) encodes how surfaces interact with light. Here, we primarily work with <b>Diffuse BSDFs</b>, which model ideal Lambertian surfaces that <b>scatter light evenly</b> in all directions. 
			The BSDF determines how much light is reflected or transmitted from an incident direction to an outgoing direction, allowing for <b>more realistic shading</b>.
		</p><br>
		
		<h3>Shading Methods for Direct Illumination</h3>
		<p>We implement two shading methods for direct illumination: <b>Uniform Hemisphere Sampling</b> and <b>Importance Sampling</b>. Both methods use <b>Monte Carlo integration</b> to approximate the rendering equation, but they differ in efficiency and convergence speed.</p>
		
		<h3>Uniform Hemisphere Sampling</h3>
		<p>
			In this method, we randomly sample directions over the hemisphere around the surface normal. For each sampled direction, we cast a <b>shadow ray</b> to check whether the light is visible from the intersection point. 
			If the shadow ray reaches a light source, we calculate the radiance contribution based on the <b>BSDF and the cosine-weighted term</b>. 
			This method follows <b>Monte Carlo integration</b>, where the average contribution of multiple random samples approximates the true lighting. However, it is <b>inefficient</b> because many sampled directions may not point toward light sources, leading to high variance and noisy shadows.
		</p> <br>
		
		<h3>Importance Sampling</h3>
		<p>
			Instead of randomly sampling directions, <b>importance sampling</b> chooses directions that are <b>more likely to contribute to illumination</b>. 
			Specifically, we sample based on the cosine-weighted distribution of the surface normal and prioritize directions toward known light sources. 
			This significantly <b>reduces variance</b> and produces <b>smoother shadows with fewer samples</b>, making it a more efficient approach compared to hemisphere sampling.
		</p><br>
		
		<h3>Rendering Examples for Uniform Hemisphere Sampling</h3>
		<p>
			Below are rendering results using Uniform Hemisphere Sampling. We rendered the images for both Uniform Hemisphere Sampling and Importance Sampling to compare their effectiveness.
		</p>
		
		<p><b>Uniform Hemisphere Sampling</b></p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="text-align: center;">
						<img src="./images/hemisphere_16_8.png" width="300px"/>
						<figcaption>Sample rate 16, light samples 8</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/hemisphere_64_32.png" width="300px"/>
						<figcaption>Sample rate 64, light samples 32</figcaption>
					</td>
				</tr>
			</table>
		</div>
		<p><b>Note:</b> The first image took <b>3.45 seconds</b> to render but appears noisy, while the second image took <b>44 seconds</b> but resulted in higher-quality shadows.</p>
		
		<p><b>Importance Sampling</b></p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="text-align: center;">
						<img src="./images/importance_1_1.png" width="300px"/>
						<figcaption>Sample rate 1, light samples 1</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/importance_1_4.png" width="300px"/>
						<figcaption>Sample rate 1, light samples 4</figcaption>
					</td>
				</tr>
				<tr>
					<td style="text-align: center;">
						<img src="./images/importance_1_16.png" width="300px"/>
						<figcaption>Sample rate 1, light samples 16</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/importance_1_64.png" width="300px"/>
						<figcaption>Sample rate 1, light samples 64</figcaption>
					</td>
				</tr>
			</table>
		</div>
		<p>
			<b> Note: </b>We also measured the rendering time for importance sampling at different light sample values:
			<ul>
				<li><b>-l 1</b>: 0.0346 seconds</li>
				<li><b>-l 4</b>: 0.1223 seconds</li>
				<li><b>-l 16</b>: 0.3355 seconds</li>
				<li><b>-l 64</b>: 1.5118 seconds</li>
			</ul>
			The results show that increasing the number of light samples significantly improves the quality of shadows but also increases rendering time. However, the rendering time is still better than uniform hemisphere sampling, especially at lower sample counts.
		</p>
		<p><b>Analysis of Importance Sampling</b><p>
			<p>
				By increasing the number of light samples (<code>-l</code>), we observe a <b>significant reduction in noise</b> in soft shadows. 
				When using <code>-l 1</code>, the shadows appear highly <b>noisy and grainy</b>, while increasing to <code>-l 64</code> results in <b>smooth and realistic</b> soft shadows. 
				Importance sampling reduces variance by <b>choosing more relevant sample directions</b>, leading to <b>faster convergence</b> compared to uniform hemisphere sampling.
			</p><br>
		
		<h3>Final Comparison Between Hemisphere and Importance Sampling</h3>
		<p>
			When comparing <b>uniform hemisphere sampling</b> and <b>importance sampling</b>, we find that importance sampling <b>produces less noise</b> in soft shadows with fewer samples. The hemisphere method wastes many samples on directions that do not contribute to illumination, making it less efficient. The  importance sampling directs rays toward known light sources, reducing variance and leading to smoother shading. As our results show that importance sampling is more reasonale for rendering soft shadows.
		</p>


		<h2>Part 4: Indirect Illumination</h2>
		<p>
			In this part, we extend our path tracing implementation to handle <b>global illumination</b>, which includes both 
			<b>direct</b> and <b>indirect</b> lighting. The core function for this is <code>at_least_one_bounce_radiance</code>, 
			which builds upon direct illumination by recursively tracing rays to capture light bouncing off surfaces. 
		</p><br>
		<h3> Walk through the implementation</h3>
		<p>
			First, we compute <b>one-bounce radiance</b> using direct lighting methods (<b>importance sampling</b> or <b>hemisphere sampling</b>). 
			Then, for <b>indirect illumination</b>, we sample a new ray direction based on the <b>BSDF</b> at the intersection point, 
			cast a new ray, and recursively compute the radiance from that new intersection. 
		</p>
		<p>
			To optimize performance, we incorporate <b>Russian Roulette termination</b>, which probabilistically stops ray recursion after a certain depth, 
			preventing unnecessary computations for rays that contribute little to the final image. 
			This method allows us to realistically capture <b>inter-reflections</b> and <b>soft color bleeding</b>, which rasterization cannot achieve. 
		</p>
		<p>
			To visualize indirect lighting effects, we compare rendered images with <b>only direct illumination</b> versus <b>only indirect illumination</b>, 
			as well as cumulative bounces up to a maximum depth. Finally, we analyze the effects of <b>sample-per-pixel rates</b>, 
			showing how increasing sample counts leads to <b>smoother and more accurate results</b>.
		</p><br>
		<h3> Examples rendered with global (direct + indirect) lightning function </h3>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="text-align: center;">
						<img src="./images/global_illumination_CBbunny.png" width="300px"/>
						<figcaption>Global Illumination_CBbunny</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/global_illumination_CBspheres.png" width="300px"/>
						<figcaption>Global Illumination_CBspheres </figcaption>
					</td>
				</tr>
			</table>
		<h3> Examples with only direct illumination vs only indirect illumination </h3>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="text-align: center;">
						<img src="./images/direct_illumination.png" width="300px"/>
						<figcaption>Only Direct Illumination</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/indirect_illumination.png" width="300px"/>
						<figcaption>Only Indirect Illumination</figcaption>
					</td>
				</tr>
			</table>
		</div>
		<p> Both the pictures were rendered in 1024 samples per pixel, 16 ligth samples per intersection, and max depth 5. Here, with only direct illumination, it only returns only <code> one_bounce_radiance(r,isect)</code>. On the other hand, for only indirect illumination, it removes <code> one_bounce_radiance() </code> when we compute only recursive bounces.</p>

		<h3> Results for different max detphs, and AccumBounces </h3>
		<p>
			We rendered images with different <b>max depths</b> and <b>accumulative bounces</b> to analyze the effects of recursive ray tracing. 
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="text-align: center;">
						<img src="./images/CBbunny_accum_0.png" width="200px"/>
						<figcaption>m=0</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_accum_1.png" width="200px"/>
						<figcaption>m=1</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_accum_2.png" width="200px"/>
						<figcaption>m=2</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_accum_3.png" width="200px"/>
						<figcaption>m=3</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_accum_4.png" width="200px"/>
						<figcaption>m=4</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_accum_5.png" width="200px"/>
						<figcaption>m=5</figcaption>
					</td>
				</tr>
			</table>
		</div>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="text-align: center;">
						<img src="./images/CBbunny_noaccum_0.png" width="200px"/>
						<figcaption>No Accum m=0</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_noaccum_1.png" width="200px"/>
						<figcaption>m=1</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_noaccum_2.png" width="200px"/>
						<figcaption>m=2</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_noaccum_3.png" width="200px"/>
						<figcaption>m=3</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_noaccum_4.png" width="200px"/>
						<figcaption>m=4</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_noaccum_5.png" width="200px"/>
						<figcaption>m=5</figcaption>
					</td>
				</tr>
			</table>
		</div>
		<p><b> Analysis for </b></p>

		<h3> Results for Russian Roulette redering for different max depth </h3>
		<p>
			We rendered images with different <b>max depths</b> and <b>Russian Roulette</b> to analyze the effects of recursive ray tracing.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="text-align: center;">
						<img src="./images/CBbunny_russian_0.png" width="200px"/>
						<figcaption>m=0</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_russian_1.png" width="200px"/>
						<figcaption>m=1</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_russian_3.png" width="200px"/>
						<figcaption>m=2</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_russian_4.png" width="200px"/>
						<figcaption>m=3</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_russian_5.png" width="200px"/>
						<figcaption>m=4</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="./images/CBbunny_russian_100.png" width="200px"/>
						<figcaption>m=100</figcaption>
					</td>
				</tr>
			</table>
		</div>


		<h2>Part 5: Adaptive Sampling</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Part 6: Extra Credit Opportunities</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
		
		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>